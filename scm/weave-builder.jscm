;; -*- mode: scheme; -*-

(load "flx/scm/fluxus.jscm")

;;------------------------------------------------------------

;; produces lists of code for each weft thread

;; avoid repeating u/d and insert f instead
(define (weave->instr kernel-code state warp)
  (if warp
      (if (zero? kernel-code)
  	  (if (eq? state "d") "fd" "d")  
  	  (if (eq? state "u") "fu" "u")) ;; 1 = warp up
      (if (zero? kernel-code)
  	  (if (eq? state "u") "fu" "u")  ;; 0 = weft up 
  	  (if (eq? state "d") "fd" "d"))))

(define (kernel-row k i)
  (list-ref k i))

(define (kernel-col k i)
  (map
   (lambda (row)
     (list-ref row i))
   k))


(define (weave-builder warp kernel thread threads state)
  (let ((i (modulo thread (length kernel))))
    (cond
     ((>= thread threads) '())
     (else
      (let ((instr (weave->instr (list-ref kernel i) state warp)))
	;;(msg (+ i ": " (list-ref kernel i) "= " instr))
	(cons
	 instr
	 (weave-builder
	  warp kernel (+ thread 1) threads
	  (cond
	   ((eq? instr "u") "u")
	   ((eq? instr "d") "d")
	   (else state)))
	 ))))))

(define (rot1 l)
  (append (cdr l) (list (car l))))

(define (weave-builder-weft kernel warp-threads weft-thread weft-threads)
    (cond
     ((>= weft-thread weft-threads) '())
     (else
      (let ((going-right (zero? (modulo weft-thread 2))))
	(let ((i (modulo weft-thread (length kernel))))
	  ;;(msg (+ i ": " (kernel-row kernel i)))
	  (append	  
	   (weave-builder
	    0 (if going-right
		  (kernel-row kernel i)
		  (rot1 (reverse (kernel-row kernel i))))
	    0 warp-threads "?")
	   (if going-right (list "r" "r") (list "l" "l"))
	   (weave-builder-weft
	    kernel warp-threads (+ weft-thread 1) weft-threads)))))))

(define (weave-builder-warp kernel warp-thread weft-threads)
  (weave-builder
   1 (kernel-col kernel (modulo warp-thread (length kernel)))
   0 weft-threads "?")))


