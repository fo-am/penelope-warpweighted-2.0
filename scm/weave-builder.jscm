;; -*- mode: scheme; -*-

(load "flx/scm/fluxus.jscm")

;;------------------------------------------------------------

;; produces lists of code for each weft thread

;; avoid repeating u/d and insert f instead
(define (weave->instr kernel-code state warp)
  (if warp
      (if (zero? kernel-code)
  	  (if (eq? state "d") "fd" "d")  
  	  (if (eq? state "u") "fu" "u")) ;; 1 = warp up
      (if (zero? kernel-code)
  	  (if (eq? state "u") "fu" "u")  ;; 0 = weft up 
  	  (if (eq? state "d") "fd" "d"))))

(define (kernel-row k i)
  (list-ref k i))

(define (kernel-col k i)
  (map
   (lambda (row)
     (list-ref row i))
   k))

(define (weave-builder warp kernel threads state)
  (let ((i (modulo (- threads 1) (length kernel))))
    (cond
     ((zero? threads) '())
     (else
      (let ((instr (weave->instr (list-ref kernel i) state warp)))
	(cons instr (weave-builder
		     warp kernel (- threads 1)
		     (cond
		      ((eq? instr "u") "u")
		      ((eq? instr "d") "d")
		      (else state)))))))))

(define (weave-builder-weft kernel weft-threads warp-threads)
    (cond
     ((zero? weft-threads) '())
     (else
      (let ((going-right (zero? (modulo weft-threads 2))))
	(let ((i (modulo weft-threads (length kernel))))
	  (append
	   (weave-builder
	    0 (if going-right
		  (kernel-row kernel i)
		  (dbg (reverse (kernel-row kernel i))))
	    warp-threads "d")
	   (if going-right (list "r" "r") (list "l" "l"))
	   (weave-builder-weft kernel (- weft-threads 1) warp-threads))))
      )))

(define (weave-builder-warp kernel weft-threads warp-thread)
  (weave-builder
   1 (kernel-col kernel (modulo warp-thread (length kernel)))
   weft-threads "d"))
